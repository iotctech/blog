---
title: 算法面试
date: 2020-06-29 10:02:55
tags:
 - 深度学习
 - 算法
 - 面试
 - 笔试
categories:
 - [deeplearning]
---

**1. n个人之间存在m个关系对，关系具有传递性，假如A关注B，B关注C，那么A就间接关注了C。如果一个人被除他之外的所有人都直接或间接关注，那么这个人就是抖音红人，求抖音红人的总数?**


**2. 特征选择有哪些方法?（介绍项目时涉及到了特征相关性分析，因此问了这个）**


**3. FM是否也能起到自动特征选择的作用，为什么?**


**4. GBDT的原理，与随机森林等算法做比较?**


**5. svm损失函数推导。**


**6. 朴素贝叶斯写公式。**


**7. 两个单链表如何找到第一个公共结点？**


**8. 由0和1组成的二维矩阵，找出1的最大连通域，计算其面积。**


**9. 介绍方向导数和梯度；方向导数和梯度的关系？为什么梯度在机器学习中的优化方法中有效？**


**10. 一辆巴士载了25人，路经10个车站。每个乘客以相同的概率在各个车站下车。如果某个车站有乘客要下车，则大巴在该站停车。每个乘客下车的行为是独立的。记大巴停车次数为X，求X的数学期望？（要求通过编程求数学期望）**


**11. 长度为n的字符串中包含m个不同的字符，如何找出包含这m个不同字符的最小子串？**


**12. 如果实现c++中的vector，只需push_back和查找两个功能，底层如何实现？**


**13. 如果用数组实现，数组初始容量为n，每次push到容量上限之后都扩容到原来的两倍，现在push进去m个数，m远大于n，求相比于m的时间复杂度？**


**14. c++中指针和引用的区别？**
- 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已;
- 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）;
- 指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化;
- 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了;
- "sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小;
- 指针和引用的自增(++)运算意义不一样;
- 用指针传递参数，可以实现对实参进行改变的目的，是因为传递过来的是实参的地址，因此使用*a实际上是取存储实参的内存单元里的数据，即是对实参进行改变;引用作为函数参数进行传递时，实质上传递的是实参本身，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。

```
/** 指针和引用的例子 **/
 
  std::string s1 = "萝卜";
  std::string s2 = "青菜";
  std::string s3 = "鸡蛋";
  std::string s4 = "西红柿";
  /** 指针可以初始化为空 **/
  std::string *p_Str = NULL;
  /** 引用一开始必须初始化 **/
  std::string& r_Str = s1;
 
  p_Str = &s2;
  std::cout<<"我是指针"<<*p_Str<<std::endl; /** 青菜 **/
  std::cout<<"我是引用"<<r_Str<<std::endl; /** 萝卜 **/
  std::cout<<std::endl;
  std::cout<<"*********分别修改指针和引用***********"<<std::endl;
  /** 分别修改指针和引用 **/
  r_Str = s3; /** 试图让r_Str为s3的别名 **/
  p_Str = &s4; /** p_Str重新指向了s4 **/
   
  std::cout<<"我是指针"<<*p_Str<<std::endl; /** 西红柿 **/
  std::cout<<"我是引用"<<r_Str<<std::endl;  /** 鸡蛋 **/
  std::cout<<std::endl;
  std::cout<<"*********查看刚刚的修改对最初初始化的影响***********"<<std::endl;
  /** 貌似成功了，都按照意图修改了，但是，稍等 **/
  std::cout<<"我是s1"<<s1<<std::endl; /** 鸡蛋 ！！！注意 ！！！ **/
  std::cout<<"我是s2"<<s2<<std::endl; /** 青菜 **/
  std::cout<<"我是s3"<<s3<<std::endl; /** 鸡蛋 **/
  std::cout<<"我是s4"<<s4<<std::endl; /** 西红柿 **/
 
  /** 
  发现s1 "萝卜" 被变成了和s3一样的"青菜"，这也说明了任何对引用的操作都等同于操作原先的变量本身
  相比较之下，指针就自由度很高了，想指向谁就指向谁，并不会影响任何之前指向过的变量
  惊不惊喜，意不意外 :)
  **/
```

**15. 如何从用户态进入内核态？**

用户态切换到内核态的3种方式:
- 系统调用
这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

- 异常
当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

- 外围设备的中断
当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。

**16. 非线性分类算法有哪些？**


**17. 如何判断一个算法是线性的还是非线性的？**


**18. 长度为n的数组中有一个数字出现了n/2次，如何快速找到这个数？**


**19. 装饰器的用法，手写计算函数调用时间的装饰器，如果函数有返回值怎么得到，闭包。**


**20. python多继承问题方法的解析顺序解析父类的同一个函数。**


**21. GIL全局解释器锁是什么，怎么来的，有什么问题？**

